# Packaging and Running a Shell Script with Nix Flakes

This repository demonstrates a clean, maintainable pattern for packaging and executing a shell script using **Nix flakes**. The goal is to bundle a script together with its runtime dependencies so it can be built and run reproducibly, without continuously editing the flake as the script evolves.

By the end of this walkthrough, you should understand:

* How to ingest an external shell script into a flake
* How to bundle runtime dependencies alongside the script
* How `symlinkJoin` and `wrapProgram` work together
* How to make the result portable across systems using `flake-utils`

---

## Quick Start

You can build the script with:

```sh
nix build
```

And run it with:

```sh
nix run .#my-script
```

No additional setup is required.

---

## The Problem We Are Solving

Our shell script depends on one external program:

* `ddate`

We want:

* These dependencies to be available at runtime
* The script to run without modifying the flake every time it changes
* A single, self-contained package that works reliably

Hard-coding dependencies or embedding the script inline in the flake quickly becomes unmaintainable. Instead, we lean on standard NixOS tooling designed specifically for this use case.

---

## High-Level Approach

The solution consists of three main pieces:

1. **Package the script itself** (without embedding it inline)
2. **Combine the script and its dependencies** into a single output
3. **Wrap the script** so its runtime `PATH` includes those dependencies

Nix provides exactly the right primitives for this.

---

## Key Building Blocks

### `symlinkJoin`

`symlinkJoin` is where most of the work happens. It creates a new derivation by *joining together* the contents of multiple packages into a single directory tree.

In this flake, we use it to join:

* Our shell script
* `ddate`
* And the output of our shell script

The result is a single `$out` directory whose `bin/` contains both executables. This guarantees that when our script is installed, its dependencies are installed alongside it.

However, simply placing binaries next to each other is not enough: we still need to ensure they are on the `PATH` when the script runs.

---

### `wrapProgram` (from `makeWrapper`)

To solve the `PATH` problem, we use the `wrapProgram` utility provided by the `makeWrapper` package.

`wrapProgram` generates a small wrapper script that:

* Modifies environment variables (such as `PATH`)
* Then `exec`s the real program

In our case:

* `makeWrapper` is added as a build dependency
* `wrapProgram` is instructed to append `$out/bin` to `PATH`

Because `$out/bin` contains both the script *and* its dependencies (thanks to `symlinkJoin`), everything is available at runtime with no global installs required.

---

## Inspecting the Result

After building:

```sh
nix build
ls -ogA result/bin
```

You will see output similar to:

```text
ddate -> /nix/store/...-ddate-0.2.2/bin/ddate
my-script
.my-script-wrapped -> /nix/store/...-my-script/bin/my-script
```

A few important observations:

* `ddate` is present, exactly as promised
* There are *two* versions of `my-script`

This is the direct result of `wrapProgram`.

---

## Understanding the Wrapped Script

### `.my-script-wrapped`

* This is a symlink to the original script
* It is produced directly from `writeScriptBin`
* If you inspect it, you will see the shell script verbatim

### `my-script`

* This is the entry point users actually execute
* It is a small wrapper generated by `wrapProgram`
* Its job is to:

  1. Update `PATH`
  2. Replace itself via `exec` with `.my-script-wrapped`

This indirection is what makes the runtime environment work correctly and transparently.

---

## Reading the Script from Disk

There are a few refinements worth calling out:

* The script is read from `./simple-script.sh` instead of being inlined
* `writeScriptBin` is used instead of `writeShellScriptBin`

  * `writeShellScriptBin` prepends a shebang
  * Our script already has one, so this avoids duplication

---

## Fixing the Shebang with `patchShebangs`

Because the script comes from disk, we also update the packageâ€™s `buildCommand` to include:

```sh
patchShebangs .
```

This ensures the interpreter path is rewritten correctly. For example:

```text
#!/usr/bin/env bash
```

Becomes something like:

```text
#!/nix/store/...-bash/bin/bash
```

This makes the script fully reproducible and independent of the host system.

---

## Making It Work Everywhere

To ensure the flake works across all common systems, we use **`flake-utils`**.

`flake-utils` solves the problem of producing outputs for multiple platforms. Since this script has no special system requirements, we can directly follow its recommended pattern.

Specifically, the flake uses:

* `eachDefaultSystem`

This generates compatible outputs for all default Nix systems without additional effort.

---

## Summary

This repository demonstrates a robust, idiomatic way to package shell scripts with Nix flakes:

* External scripts are ingested cleanly
* Dependencies are bundled without global installs
* Runtime environments are handled explicitly and safely
* The result is portable, reproducible, and maintainable

